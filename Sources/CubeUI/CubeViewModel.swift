#if canImport(SwiftUI)
//
//  CubeViewModel.swift
//  CubeSolver
//
//  Created by GitHub Copilot
//

import Foundation
import SwiftUI
import CubeCore

/// ViewModel managing the state and operations of the Rubik's Cube
/// Conforms to ObservableObject to enable SwiftUI data binding
@MainActor
public class CubeViewModel: ObservableObject {
    /// The current state of the Rubik's Cube
    @Published public var cube: RubiksCube
    
    /// Array of solution steps generated by the solver
    @Published public var solutionSteps: [String] = []
    
    /// Typed moves for enhanced solver
    @Published public var solution: [Move] = []
    
    /// Current solving state
    @Published public var isSolving: Bool = false
    
    /// Error message if solving fails
    @Published public var errorMessage: String?
    
    /// History manager for saved solves
    public let historyManager = SolveHistoryManager()
    
    /// Privacy settings
    public let privacySettings = PrivacySettings()
    
    /// Analytics tracker
    public lazy var analyticsTracker = AnalyticsTracker(privacySettings: privacySettings)
    
    /// Initializes the view model with a solved cube
    public init() {
        self.cube = RubiksCube()
    }
    
    /// Scrambles the cube with a random sequence of moves
    /// - Note: Clears any existing solution steps
    public func scramble() {
        let scrambleMoves = EnhancedCubeSolver.generateScramble(moveCount: 20)
        var state = CubeState(from: cube)
        EnhancedCubeSolver.applyMoves(to: &state, moves: scrambleMoves)
        cube = state.toRubiksCube()
        solutionSteps = []
        solution = []
        errorMessage = nil
    }
    
    /// Solves the current cube configuration asynchronously
    /// - Note: Updates the solution array with the solving algorithm's moves
    public func solveAsync() async {
        isSolving = true
        errorMessage = nil
        
        do {
            let cubeState = CubeState(from: cube)
            let moves = try await EnhancedCubeSolver.solveCubeAsync(from: cubeState)
            
            await MainActor.run {
                self.solution = moves
                self.solutionSteps = moves.map { $0.notation }
                
                // Save to history if enabled
                if privacySettings.saveSolveHistory {
                    let savedSolve = SavedSolve(
                        initialState: cubeState,
                        solution: moves,
                        moveCount: moves.count
                    )
                    historyManager.saveSolve(savedSolve)
                }
                
                // Track solve event
                analyticsTracker.trackSolve(moveCount: moves.count, solveTime: 0)
                
                isSolving = false
            }
        } catch {
            await MainActor.run {
                self.errorMessage = error.localizedDescription
                self.isSolving = false
            }
        }
    }
    
    /// Solves the current cube configuration (synchronous version)
    /// - Note: Uses EnhancedCubeSolver for consistent algorithm
    public func solve() {
        do {
            let cubeState = CubeState(from: cube)
            let moves = try EnhancedCubeSolver.solveCube(from: cubeState)
            solution = moves
            solutionSteps = moves.map { $0.notation }
        } catch {
            errorMessage = error.localizedDescription
            solutionSteps = []
            solution = []
        }
    }
    
    /// Resets the cube to its solved state and clears solution steps
    public func reset() {
        cube = RubiksCube()
        solutionSteps = []
        solution = []
        errorMessage = nil
    }
}
#endif
